# This is the config file for a class S theory of A_3 type
# one a sphere with four equal punctures.
# At x_1, x_2, x_3, x_4 we have punctures of types [2,1,1]
# The residues are 
# phi = (dz / z) diag(m_i, m_i , M_i, -2 * m_i - M_i)

[Seiberg-Witten data]

#
# Option 1 - generic x_i
#
#
#casimir_differentials = {2: (2 * (x_1-x_2) * (x_1-x_3) * (x_1-x_4) * (2 * m_1 * M_1 + 3 * m_1^2 + M_1^2) * (z-x_2) * (z-x_3) * (z-x_4) + 2 * (x_2-x_1) * (x_2-x_3) * (x_2-x_4) * (2 * m_2 * M_2 + 3 * m_2^2 + M_2^2) * (z-x_1) * (z-x_3) * (z-x_4)+2 * (x_3-x_1) * (x_3-x_2) * (x_3-x_4) * (2 * m_3 * M_3+3 * m_3^2+M_3^2) * (z-x_1) * (z-x_2) * (z-x_4)+2 * (x_4-x_1) * (x_4-x_2) * (x_4-x_3) * (2 * m_4 * M_4+3 * m_4^2 + M_4^2) * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2) + u_2 / ((z-x_1) * (z-x_2) * (z-x_3) * (z-x_4)), 3: (z^2 * u_3_0+z * u_3_1+u_3_2) / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2) + (-6 * m_1 * (x_1-x_2)^2 * (x_1-x_3)^2 * (x_1-x_4)^2 * (m_1+M_1)^2 * (z-x_2) * (z-x_3) * (z-x_4)-6 * m_2 * (x_2-x_1)^2 * (x_2-x_3)^2 * (x_2-x_4)^2 * (m_2+M_2)^2 * (z-x_1) * (z-x_3) * (z-x_4)-6 * m_3 * (x_3-x_1)^2 * (x_3-x_2)^2 * (x_3-x_4)^2 * (m_3+M_3)^2 * (z-x_1) * (z-x_2) * (z-x_4)-6 * m_4 * (x_4-x_1)^2 * (x_4-x_2)^2 * (x_4-x_3)^2 * (m_4+M_4)^2 * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^3 * (z-x_2)^3 * (z-x_3)^3 * (z-x_4)^3), 4: ((x_1-x_2)^3 * (x_1-x_3)^3 * (x_1-x_4)^3 * ((2 * m_1+M_1)^4+2 * m_1^4+M_1^4) * (z-x_2) * (z-x_3) * (z-x_4)+(x_2-x_1)^3 * (x_2-x_3)^3 * (x_2-x_4)^3 * ((2 * m_2+M_2)^4+2 * m_2^4+M_2^4) * (z-x_1) * (z-x_3) * (z-x_4)+(x_3-x_1)^3 * (x_3-x_2)^3 * (x_3-x_4)^3 * ((2 * m_3+M_3)^4+2 * m_3^4+M_3^4) * (z-x_1) * (z-x_2) * (z-x_4)+(x_4-x_1)^3 * (x_4-x_2)^3 * (x_4-x_3)^3 * ((2 * m_4+M_4)^4+2 * m_4^4+M_4^4) * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^4 * (z-x_2)^4 * (z-x_3)^4 * (z-x_4)^4)+ u_4 / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2)}
#
# WARNING: taking the origin of the coulomb branch seems wrong, because the degree of the discriminant changes there. So this may be a singular locus.
#
#differential_parameters = {u_2 : 0, u_3_0 : 0, u_3_1 : 0, u_3_2 : 0, u_4 : 0, m_1 : (1+I)/5, M_1 : (-I)/3, m_2 : (1+I)/5, M_2 : (-I)/3, m_3 : (1+I)/5, M_3 : (-I)/3, m_4 : (1+I)/5, M_4 : (-I)/3, x_1 : 1, x_2 : -1, x_3 : I, x_4 : -I}
#
#root_system = A3
#representation = 1
#regular_punctures = [1, -1, I, -I]
#irregular_punctures = []

######################

#
# Option 2 - x_1=0, x_2 = 1, x_3 = x_0, x_4 = oo
#

casimir_differentials = {2: (2 * (z-1) * z^2 * (2 * m_4 * M_4+3 * m_4^2+M_4^2) * (z-x_0)+2 * (1-x_0) * z * (2 * m_2 * M_2+3 * m_2^2+M_2^2) * (z-x_0)+2 * (x_0-1) * x_0 * (z-1) * z * (2 * m_3 * M_3+3 * m_3^2+M_3^2)+2 * x_0 * (z-1) * (2 * m_1 * M_1+3 * m_1^2+M_1^2) * (z-x_0)) / ((z-1)^2 * z^2 * (z-x_0)^2 ) + u_2 / ((z-1) * z * (z-x_0)), 3: (z^2 * u_3_0+z * u_3_1+u_3_2 ) / ((z-1)^2 * z^2 * (z-x_0)^2)+  ( 6 * m_4 * (z-1) * z^4 * (m_4+M_4)^2 * (z-x_0)-6 * m_3 * (x_0-1)^2 * x_0^2 * (z-1) * z * (m_3+M_3)^2-6 * m_2 * (1-x_0)^2 * z * (m_2+M_2)^2 * (z-x_0)-6 * m_1 * x_0^2 * (z-1) * (m_1+M_1)^2 * (z-x_0) ) / ((z-1)^3 * z^3 * (z-x_0)^3 ), 4: ((z-1) * z^6 * ((2 * m_4+M_4)^4+2 * m_4^4+M_4^4) * (z-x_0)+(x_0-1)^3 * x_0^3 * (z-1) * z * ((2 * m_3+M_3)^4+2 * m_3^4+M_3^4)+(1-x_0)^3 * z * ((2 * m_2+M_2)^4+2 * m_2^4+M_2^4) * (z-x_0)+x_0^3 * (z-1) * ((2 * m_1+M_1)^4+2 * m_1^4+M_1^4) * (z-x_0) ) / ((z-1)^4 * z^4 * (z-x_0)^4)+u_4 / ((z-1)^2 * z^2 * (z-x_0)^2)}


# differential_parameters = {u_2 : 1, u_3_0 : 0, u_3_1 : 0, u_3_2 : 0, u_4 : 0, m_1 : 1, M_1 : 1, m_2 : 1, M_2 : 1, m_3 : 1, M_3 : 1, m_4 : 1, M_4 : 1, x_0 : -1}

differential_parameters = {u_2 : 1/7, u_3_0 : I/2-1/5, u_3_1 : -1/3+I/2, u_3_2 : 1/5, u_4 : I/10, m_1 : 1, M_1 : I, m_2 : 1, M_2 : I, m_3 : 1, M_3 : I, m_4 : 1, M_4 : I, x_0 : -2}

root_system = A3
representation = 1
regular_punctures = [0, 1, -1, oo]
irregular_punctures = []


##########




# Mobius transformation parameters
# mt_params = None 
ramification_point_finding_method = discriminant 
# ramification_point_finding_method = system_of_eqs 

[numerical parameters]

#default range as [[z.real.min, z.real.max], [z.imag.min, z.imag.max]]
plot_range = [[-5, 5], [-5, 5]]

num_of_steps = 10000 
num_of_iterations = 2
size_of_small_step = 1e-3
size_of_large_step = 2e-2
size_of_bp_neighborhood = 10 * %(size_of_small_step)s
size_of_puncture_cutoff = 1.5e-1
accuracy = 1e-6

# Number of processes to spawn. 
# Set to 0 to utilize maximum number of cores available,
# Set to -n, n > 0, to leave n CPUs out of the process pool.
#n_processes = 30

mass_limit = 15.0
phase = [1e-6, 3.141592, 20]
