# This is the config file for a class S theory of A_3 type
# one a sphere with four equal punctures.
# At x_1, x_2, x_3, x_4 we have punctures of types [2,1,1]
# The residues are 
# phi = (dz / z) diag(m_i, m_i , M_i, -2 * m_i - M_i)

[Seiberg-Witten data]

casimir_differentials = {2: (2 * (x_1-x_2) * (x_1-x_3) * (x_1-x_4) * (2 * m_1 * M_1 + 3 * m_1^2 + M_1^2) * (z-x_2) * (z-x_3) * (z-x_4) + 2 * (x_2-x_1) * (x_2-x_3) * (x_2-x_4) * (2 * m_2 * M_2 + 3 * m_2^2 + M_2^2) * (z-x_1) * (z-x_3) * (z-x_4)+2 * (x_3-x_1) * (x_3-x_2) * (x_3-x_4) * (2 * m_3 * M_3+3 * m_3^2+M_3^2) * (z-x_1) * (z-x_2) * (z-x_4)+2 * (x_4-x_1) * (x_4-x_2) * (x_4-x_3) * (2 * m_4 * M_4+3 * m_4^2 + M_4^2) * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2) + u_2 / ((z-x_1) * (z-x_2) * (z-x_3) * (z-x_4)), 3: (z^2 * u_3_0+z * u_3_1+u_3_2) / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2) + (-6 * m_1 * (x_1-x_2)^2 * (x_1-x_3)^2 * (x_1-x_4)^2 * (m_1+M_1)^2 * (z-x_2) * (z-x_3) * (z-x_4)-6 * m_2 * (x_2-x_1)^2 * (x_2-x_3)^2 * (x_2-x_4)^2 * (m_2+M_2)^2 * (z-x_1) * (z-x_3) * (z-x_4)-6 * m_3 * (x_3-x_1)^2 * (x_3-x_2)^2 * (x_3-x_4)^2 * (m_3+M_3)^2 * (z-x_1) * (z-x_2) * (z-x_4)-6 * m_4 * (x_4-x_1)^2 * (x_4-x_2)^2 * (x_4-x_3)^2 * (m_4+M_4)^2 * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^3 * (z-x_2)^3 * (z-x_3)^3 * (z-x_4)^3), 4: ((x_1-x_2)^3 * (x_1-x_3)^3 * (x_1-x_4)^3 * ((2 * m_1+M_1)^4+2 * m_1^4+M_1^4) * (z-x_2) * (z-x_3) * (z-x_4)+(x_2-x_1)^3 * (x_2-x_3)^3 * (x_2-x_4)^3 * ((2 * m_2+M_2)^4+2 * m_2^4+M_2^4) * (z-x_1) * (z-x_3) * (z-x_4)+(x_3-x_1)^3 * (x_3-x_2)^3 * (x_3-x_4)^3 * ((2 * m_3+M_3)^4+2 * m_3^4+M_3^4) * (z-x_1) * (z-x_2) * (z-x_4)+(x_4-x_1)^3 * (x_4-x_2)^3 * (x_4-x_3)^3 * ((2 * m_4+M_4)^4+2 * m_4^4+M_4^4) * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^4 * (z-x_2)^4 * (z-x_3)^4 * (z-x_4)^4)+ u_4 / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2)}




#casimir_differentials = {2: (2 * (x_1-x_2) * (x_1-x_3) * (x_1-x_4) * (2 * m_1 * M_1 + 3 * m_1^2 + M_1^2) * (z-x_2) * (z-x_3) * (z-x_4) + 2 * (x_2-x_1) * (x_2-x_3) * (x_2-x_4) * (2 * m_2 * M_2 + 3 * m_2^2 + M_2^2) * (z-x_1) * (z-x_3) * (z-x_4)+2 * (x_3-x_1) * (x_3-x_2) * (x_3-x_4) * (2 * m_3 * M_3+3 * m_3^2+M_3^2) * (z-x_1) * (z-x_2) * (z-x_4)+2 * (x_4-x_1) * (x_4-x_2) * (x_4-x_3) * (2 * m_4 * M_4+3 * m_4^2 + M_4^2) * (z-x_1) * (z-x_2) * (z-x_3)) / ((z-x_1)^2 * (z-x_2)^2 * (z-x_3)^2 * (z-x_4)^2) + u_2 / ((z-x_1) * (z-x_2) * (z-x_3) * (z-x_4)), 3: 0, 4 : 0}

differential_parameters = {u_2 : 0, u_3_0 : 0, u_3_1 : 0, u_3_2 : 0, u_4 : 0, m_1 : (1+I)/5, M_1 : (-I)/3, m_2 : (1+I)/5, M_2 : (-I)/3, m_3 : (1+I)/5, M_3 : (-I)/3, m_4 : (1+I)/5, M_4 : (-I)/3, x_1 : 1, x_2 : -1, x_3 : I, x_4 : -I}

#differential_parameters = {u_2 : 0, u_3_0 : 0, u_3_1 : 0, u_3_2 : 0, u_4 : 0, m_1 : (1+I)/5, M_1 : (-I)/3, m_2 : 0, M_2 : 0, m_3 : 0, M_3 : 0, m_4 : 0, M_4 :0, x_1 : 1, x_2 : -1, x_3 : I, x_4 : -I}

root_system = A3
representation = 1
regular_punctures = [1, -1, I, -I]
irregular_punctures = []



# Mobius transformation parameters
# mt_params = None 
ramification_point_finding_method = discriminant 
# ramification_point_finding_method = system_of_eqs 

[numerical parameters]

#default range as [[z.real.min, z.real.max], [z.imag.min, z.imag.max]]
plot_range = [[-5, 5], [-5, 5]]

num_of_steps = 5000 
num_of_iterations = 1
size_of_small_step = 1e-3
size_of_large_step = 2e-2
size_of_bp_neighborhood = 10 * %(size_of_small_step)s
accuracy = 1e-6

# Number of processes to spawn. 
# Set to 0 to utilize maximum number of cores available,
# Set to -n, n > 0, to leave n CPUs out of the process pool.
#n_processes = 30

mass_limit = 7.0
phase = [1e-6, 3.141592, 20]
