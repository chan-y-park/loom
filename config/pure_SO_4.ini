[Seiberg-Witten data]
#casimir_differentials = {2: (1/(z*r) + u_2 + (z*r))*(1/(z*r)^2),
#                         4: u_4/(z*r)^4}
casimir_differentials = {2: (1/z + u_2 + z)*(1/z^2),
                         4: u_4/z^4}
root_system = D2
representation = 1
punctures = [0, oo]
differential_parameters = {u_2: -1+I, u_4: 5/2*I}
#differential_parameters = {u_2: -1, u_4: 5/2}
# Mobius transformation parameters
#mt_params = [[5*I, -3], [1, 1]]
mt_params = [[I,-I],[1,1]]
#ramification_point_finding_method = discriminant 
#ramification_point_finding_method = system_of_eqs 

[numerical parameters]

#default range as [[z.real.min, z.real.max], [z.imag.min, z.imag.max]]
plot_range = [[-5, 5], [-5, 5]]

num_of_steps = 5000 
num_of_iterations = 5
size_of_small_step = 1e-3
size_of_large_step = 2e-2

size_of_neighborhood = 10 * %(size_of_small_step)s
size_of_puncture_cutoff = 2 * %(size_of_small_step)s
size_of_ramification_pt_cutoff = 1e-3

accuracy = 1e-6

# Number of processes to spawn. 
# Set to 0 to utilize maximum number of cores available,
# Set to -n, n > 0, to leave n CPUs out of the process pool.
n_processes = 0

phase_range = [1e-6, 3.141592, 10]
mass_limit = 10.0
